package collection

import (
	"errors"
	"math/rand"
	"reflect"
	"sort"
	"sync"
)

// Collection представляет собой потокобезопасную коллекцию, аналогичную Map.
// Используется для хранения элементов с уникальными ключами и предоставляет множество полезных методов.
type Collection[K comparable, V any] struct {
	data  map[K]V
	order []K
	mutex sync.RWMutex
}

// New создает новую пустую коллекцию.
func New[K comparable, V any]() *Collection[K, V] {
	return &Collection[K, V]{
		data: make(map[K]V),
	}
}

// Set добавляет или обновляет пару ключ-значение в коллекции.
//
// Параметры:
//   - key: ключ типа K (должен быть comparable)
//   - value: значение типа V (любого типа)
//
// Особенности работы:
//   - Если ключ уже существует, его значение будет перезаписано
//   - Гарантирует потокобезопасность (использует эксклюзивную блокировку)
//   - Не возвращает ошибок (поведение аналогично встроенному map в Go)
//   - Сложность O(1) (как у стандартного map)
//
// Примеры использования:
//
// 1. Базовое добавление элемента:
// coll := collection.New[string, int]()
// coll.Set("age", 25)  // Добавляет новую пару
//
// 2. Обновление существующего элемента:
// coll.Set("age", 26)  // Перезаписывает значение
//
// 3. Использование различных типов:
// coll2 := collection.New[int, struct{}]()
// coll2.Set(1, struct{}{})  // Поддерживает любые comparable-ключи и значения
//
// 4. Потокобезопасность:
//
//	go func() {
//	    coll.Set("a", 1)  // Безопасно для конкурентного доступа
//	}()
//
//	go func() {
//	    coll.Set("b", 2)
//	}()
func (c *Collection[K, V]) Set(key K, value V) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	c.data[key] = value
}

// Get возвращает значение, ассоциированное с заданным ключом.
//
// Параметры:
//   - key: ключ типа K (должен быть comparable)
//
// Возвращаемые значения:
//   - V: Значение, связанное с переданным ключом. Если ключ не найден, возвращает нулевое значение для типа V.
//   - bool: Флаг наличия ключа. true, если ключ существует в коллекции; false — если нет.
//
// Особенности работы:
//   - Использует только чтение блокировки (RLock), что гарантирует потокобезопасность при одновременном доступе несколькими горутинами.
//   - Функция не возвращает ошибок, поэтому её поведение аналогично стандартному map в Go.
//   - Сложность O(1) операции извлечения, как и у стандартного map.
//
// Примеры использования:
//
// 1. Базовое получение значения по ключу:
//
// coll := collection.New[string, int]()
// coll.Set("age", 25)
//
// age, ok := coll.Get("age")
// Если ok == true, то age равен 25.
//
// 2. Попытка получить значение для несуществующего ключа:
// country, ok := coll.Get("country")
// В этом случае, country будет иметь нулевое значение для типа int, а ok == false.
func (c *Collection[K, V]) Get(key K) (V, bool) {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	val, ok := c.data[key]
	return val, ok
}

// Has проверяет наличие ключа в коллекции.
//
// Параметры:
//   - key: ключ типа K (должен быть comparable)
//
// Возвращаемые значения:
//   - bool: Флаг наличия ключа. true, если ключ существует в коллекции; false — если нет.
//
// Особенности работы:
//   - Использует только чтение блокировки (RLock), что гарантирует потокобезопасность при одновременном доступе несколькими горутинами.
//   - Функция не возвращает ошибок и не возвращает само значение, только факт наличия ключа.
//   - Сложность O(1) операции проверки, как и у стандартного map.
//
// Примеры использования:
//
// 1. Проверка существующего ключа:
//
// coll := collection.New[string, int]()
// coll.Set("age", 25)
//
// exists := coll.Has("age")
// exists будет равен true.
//
// 2. Проверка несуществующего ключа:
// exists := coll.Has("country")
// В этом случае exists будет равен false.
func (c *Collection[K, V]) Has(key K) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	_, ok := c.data[key]
	return ok
}

// Delete удаляет ключ и связанное с ним значение из коллекции.
//
// Параметры:
//   - key: ключ типа K (должен быть comparable)
//
// Возвращаемые значения:
//   - Нет (функция ничего не возвращает)
//
// Особенности работы:
//   - Использует эксклюзивную блокировку (Lock), что гарантирует потокобезопасность при изменении коллекции.
//   - Если ключ не существует, функция завершается без ошибок (аналогично поведению `delete` в стандартном map).
//   - Сложность операции O(1), как и у стандартного `delete` в map.
//
// Примеры использования:
//
// 1. Удаление существующего ключа:
//
// coll := collection.New[string, int]()
// coll.Set("age", 25)
//
// coll.Delete("age")  // Ключ "age" и значение 25 удалены
//
// 2. Попытка удаления несуществующего ключа:
// coll.Delete("country")  // Ничего не происходит, ошибки нет
func (c *Collection[K, V]) Delete(key K) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	delete(c.data, key)
}

// Size возвращает текущее количество элементов в коллекции.
//
// Возвращаемые значения:
//   - int: Количество элементов (пар ключ-значение) в коллекции.
//
// Особенности работы:
//   - Использует только чтение блокировки (RLock), что гарантирует потокобезопасность при одновременном доступе несколькими горутинами.
//   - Возвращает 0, если коллекция пуста.
//   - Сложность O(1) операции, так как используется встроенная функция len() для map.
//
// Примеры использования:
//
// 1. Получение размера непустой коллекции:
//
// coll := collection.New[string, int]()
// coll.Set("age", 25)
// coll.Set("name", "Alice")
//
// count := coll.Size()
// count будет равен 2.
//
// 2. Получение размера пустой коллекции:
// emptyColl := collection.New[string, float64]()
// count := emptyColl.Size()
// В этом случае count будет равен 0.
func (c *Collection[K, V]) Size() int {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	return len(c.data)
}

// Keys возвращает срез всех ключей, присутствующих в коллекции.
//
// Возвращаемые значения:
//   - []K: Срез ключей типа K. Порядок ключей не гарантируется.
//
// Особенности работы:
//   - Использует только чтение блокировки (RLock), что гарантирует потокобезопасность.
//   - Возвращает пустой срез, если коллекция пуста.
//   - Сложность операции O(n), где n - количество элементов в коллекции.
//   - Выделяет новый срез для возвращаемых ключей (изменение возвращенного среза не влияет на коллекцию).
//
// Примеры использования:
//
// 1. Получение ключей из непустой коллекции:
//
// coll := collection.New[string, int]()
// coll.Set("age", 25)
// coll.Set("name", "Alice")
//
// keys := coll.Keys()
// keys может содержать ["age", "name"] или ["name", "age"] (порядок не гарантируется)
//
// 2. Получение ключей из пустой коллекции:
//
// emptyColl := collection.New[int, string]()
// keys := emptyColl.Keys()
// len(keys) будет равен 0
func (c *Collection[K, V]) Keys() []K {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	keys := make([]K, 0, len(c.data))
	for k := range c.data {
		keys = append(keys, k)
	}
	return keys
}

// Values возвращает срез всех значений, присутствующих в коллекции.
//
// Возвращаемые значения:
//   - []V: Срез значений типа V. Порядок значений соответствует итерации по map и не гарантируется.
//
// Особенности работы:
//   - Использует блокировку чтения (RLock), обеспечивая потокобезопасность при конкурентном доступе
//   - Возвращает пустой срез, если коллекция не содержит элементов
//   - Сложность операции O(n), где n - количество элементов в коллекции
//   - Создает и возвращает новый срез (изменение возвращенного среза не влияет на коллекцию)
//   - Может содержать дубликаты значений, если они были добавлены для разных ключей
//
// Примеры использования:
//
// 1. Получение значений из непустой коллекции:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 1) // Дубликат значения
//
// values := coll.Values()
// Может вернуть [1, 2, 1], [2, 1, 1] или другой порядок
//
// 2. Получение значений из пустой коллекции:
// emptyColl := collection.New[string, float64]()
// values := emptyColl.Values()
// len(values) будет равен 0
func (c *Collection[K, V]) Values() []V {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	values := make([]V, 0, len(c.data))
	for _, v := range c.data {
		values = append(values, v)
	}
	return values
}

// Clear полностью очищает коллекцию, удаляя все пары ключ-значение.
//
// Особенности работы:
//   - Использует эксклюзивную блокировку (Lock), гарантируя потокобезопасность операции
//   - Заменяет внутреннюю map новой пустой map, вместо поэлементного удаления
//   - Сложность операции O(1) (в отличие от O(n) при поэлементном удалении)
//   - После выполнения коллекция становится пустой (Size() вернет 0)
//   - Не возвращает ошибок и не требует проверки результата
//
// Примеры использования:
//
// 1. Очистка непустой коллекции:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
//
// coll.Clear()  // Удаляет все элементы
// count := coll.Size()  // count будет равен 0
//
// 2. Очистка уже пустой коллекции:
// emptyColl := collection.New[int, string]()
// emptyColl.Clear()  // Нет эффекта, коллекция остается пустой
func (c *Collection[K, V]) Clear() {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	c.data = make(map[K]V)
}

// Ensure возвращает значение для указанного ключа, а если ключ отсутствует -
// добавляет его в коллекцию с значением, сгенерированным переданной функцией.
//
// Параметры:
//   - key: ключ типа K (должен быть comparable)
//   - defaultValueGenerator: функция, генерирующая значение по умолчанию для ключа
//
// Возвращаемые значения:
//   - V: существующее значение, если ключ присутствовал, либо новое сгенерированное значение
//
// Особенности работы:
//   - Использует эксклюзивную блокировку (Lock) для атомарной проверки и вставки
//   - Гарантирует, что defaultValueGenerator вызовется только если ключ отсутствует
//   - Не вызывает defaultValueGenerator для существующих ключей
//   - Сложность O(1) для существующих ключей, O(1) + сложность defaultValueGenerator для новых
//   - Полезен для реализации кэшей, ленивой инициализации и thread-safe вычислений
//
// Примеры использования:
//
// 1. Получение существующего значения:
//
// coll := collection.New[string, int]()
// coll.Set("count", 5)
//
//	val := coll.Ensure("count", func(k string) int {
//	    return 0 // Не выполнится, так как ключ существует
//	})
//
// val будет равен 5
//
// 2. Добавление нового значения:
//
// coll := collection.New[int, *Config]()
//
//	config := coll.Ensure(42, func(id int) *Config {
//	    return &Config{ID: id} // Создается новый Config только если ключа 42 нет
//	})
//
// config будет содержать новый экземпляр Config с ID=42
func (c *Collection[K, V]) Ensure(key K, defaultValueGenerator func(K) V) V {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	if val, ok := c.data[key]; ok {
		return val
	}
	defaultValue := defaultValueGenerator(key)
	c.data[key] = defaultValue
	return defaultValue
}

// HasAll проверяет, содержатся ли все указанные ключи в коллекции.
//
// Параметры:
//   - keys: вариативный список ключей для проверки (тип K)
//
// Возвращаемые значения:
//   - bool: true если ВСЕ переданные ключи существуют в коллекции, false если отсутствует хотя бы один
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Возвращает true для пустого списка ключей (вакуумная истина)
//   - Работает по принципу "короткого замыкания" - прекращает проверку при первом отсутствующем ключе
//   - Сложность O(n) где n - количество переданных ключей (в худшем случае)
//   - Не изменяет состояние коллекции
//
// Примеры использования:
//
// 1. Проверка набора существующих ключей:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
// exists := coll.HasAll("a", "b") // true
// exists = coll.HasAll("a", "x")  // false
//
// 2. Граничные случаи:
// exists := coll.HasAll()       // true (нет ключей для проверки)
// exists = coll.HasAll("x")     // false
// exists = coll.HasAll("a", "") // false если "" отсутствует
func (c *Collection[K, V]) HasAll(keys ...K) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	for _, k := range keys {
		if _, ok := c.data[k]; !ok {
			return false
		}
	}
	return true
}

// HasAny проверяет, содержится ли хотя бы один из указанных ключей в коллекции.
//
// Параметры:
//   - keys: вариативный список ключей для проверки (тип K)
//
// Возвращаемые значения:
//   - bool: true если ХОТЯ БЫ ОДИН из переданных ключей существует в коллекции,
//     false если ни одного ключа нет или список ключей пуст
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Возвращает false для пустого списка ключей
//   - Работает по принципу "короткого замыкания" - прекращает проверку при первом найденном ключе
//   - Сложность O(n) где n - количество переданных ключей (в худшем случае)
//   - Не изменяет состояние коллекции
//
// Примеры использования:
//
// 1. Проверка наличия любого ключа из набора:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
//
// exists := coll.HasAny("a", "x", "y") // true ("a" существует)
// exists = coll.HasAny("x", "y")      // false
//
// 2. Граничные случаи:
// exists := coll.HasAny()       // false (нет ключей для проверки)
// exists = coll.HasAny("a")     // true
// exists = coll.HasAny("", "a") // true если любой из ключей существует
func (c *Collection[K, V]) HasAny(keys ...K) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	for _, k := range keys {
		if _, ok := c.data[k]; ok {
			return true
		}
	}
	return false
}

// First возвращает первые N значений из коллекции.
//
// Параметры:
//   - amount: опциональное количество значений для возврата (по умолчанию 1)
//
// Возвращаемые значения:
//   - []V: срез значений. Если указано N=0 или N больше размера коллекции,
//     возвращаются все значения. При отрицательном N возвращает первое значение.
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - При отсутствии параметров возвращает первое значение (в срезе длины 1)
//   - Порядок значений соответствует итерации по map и не гарантируется
//   - Сложность O(n) где n - размер коллекции (из-за необходимости получить все значения)
//   - Возвращает новый срез (изменение возвращенного среза не влияет на коллекцию)
//
// Примеры использования:
//
// 1. Получение первого значения:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
// first := coll.First()    // [1] (или другое значение - порядок не гарантирован)
//
// 2. Получение нескольких значений:
// firstTwo := coll.First(2) // [1, 2] (если такие были первыми при итерации)
//
// 3. Граничные случаи:
// all := coll.First(0)      // все значения (как Values())
// all = coll.First(100)     // все значения (если коллекция меньше 100 элементов)
// empty := coll.First(-5)   // первое значение (поведение по умолчанию)
func (c *Collection[K, V]) First(amount ...int) []V {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	var n int
	if len(amount) == 0 || amount[0] < 0 {
		n = 1
	} else {
		n = amount[0]
	}
	if n <= 0 || n >= len(c.data) {
		return c.Values()
	}
	values := c.Values()
	return values[:n]
}

// Last возвращает последние N значений из коллекции.
//
// Параметры:
//   - amount: опциональное количество значений для возврата (по умолчанию 1)
//
// Возвращаемые значения:
//   - []V: срез значений. Если указано N=0 или N больше размера коллекции,
//     возвращаются все значения. При отрицательном N возвращает последнее значение.
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - При отсутствии параметров возвращает последнее значение (в срезе длины 1)
//   - Порядок значений соответствует обратному порядку итерации по map и не гарантируется
//   - Сложность O(n) где n - размер коллекции (из-за необходимости получить все значения)
//   - Возвращает новый срез (изменение возвращенного среза не влияет на коллекцию)
//   - В отличие от First(), возвращает элементы с конца коллекции
//
// Примеры использования:
//
// 1. Получение последнего значения:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
// last := coll.Last()    // [3] (или другое значение - порядок не гарантирован)
//
// 2. Получение нескольких последних значений:
// lastTwo := coll.Last(2) // [2, 3] (если такие были последними при итерации)
//
// 3. Граничные случаи:
// all := coll.Last(0)      // все значения (как Values())
// all = coll.Last(100)     // все значения (если коллекция меньше 100 элементов)
// empty := coll.Last(-5)   // последнее значение (поведение по умолчанию)
func (c *Collection[K, V]) Last(amount ...int) []V {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	var n int
	if len(amount) == 0 || amount[0] < 0 {
		n = 1
	} else {
		n = amount[0]
	}
	if n <= 0 || n >= len(c.data) {
		return c.Values()
	}
	values := c.Values()
	return values[len(values)-n:]
}

// At возвращает значение по индексу в коллекции.
//
// Параметры:
//   - index: позиция элемента (отрицательные значения отсчитываются с конца)
//
// Возвращаемые значения:
//   - V: найденное значение
//   - error: ошибка если индекс выходит за границы коллекции
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Поддерживает отрицательные индексы (-1 = последний элемент)
//   - Сложность O(n) из-за необходимости преобразования в срез
//   - Порядок элементов соответствует итерации по map и не гарантируется
//   - В отличие от Get(), работает с числовыми индексами вместо ключей
//
// Примеры использования:
//
// 1. Получение элемента по положительному индексу:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
// val, err := coll.At(1)  // возвращает второй элемент (например, 2)
//
// 2. Использование отрицательного индекса:
// val, err := coll.At(-1) // возвращает последний элемент
//
// 3. Обработка ошибок:
// val, err := coll.At(5)  // err != nil, val = zero value
// val, err := coll.At(-10) // err != nil, val = zero value
func (c *Collection[K, V]) At(index int) (V, error) {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	index = normalizeIndex(len(c.data), index)
	if index < 0 || index >= len(c.data) {
		var zero V
		return zero, errors.New("index out of bounds")
	}
	return c.Values()[index], nil
}

// KeyAt возвращает ключ по индексу в коллекции.
//
// Параметры:
//   - index: позиция элемента (отрицательные значения отсчитываются с конца)
//
// Возвращаемые значения:
//   - K: найденный ключ
//   - error: ошибка если индекс выходит за границы коллекции
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Поддерживает отрицательные индексы (-1 = последний элемент)
//   - Сложность O(n) из-за необходимости преобразования map в срез ключей
//   - Порядок ключей соответствует порядку итерации по map и не гарантируется
//   - В отличие от At(), возвращает ключ вместо значения
//
// Примеры использования:
//
// 1. Получение ключа по положительному индексу:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
// key, err := coll.KeyAt(1)  // возвращает второй ключ (например, "b")
//
// 2. Использование отрицательного индекса:
// key, err := coll.KeyAt(-1) // возвращает последний ключ (например, "c")
//
// 3. Обработка ошибок:
// key, err := coll.KeyAt(5)    // err != nil, key = zero value
// key, err := coll.KeyAt(-10)  // err != nil, key = zero value
func (c *Collection[K, V]) KeyAt(index int) (K, error) {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	index = normalizeIndex(len(c.data), index)
	if index < 0 || index >= len(c.data) {
		var zero K
		return zero, errors.New("index out of bounds in collection")
	}
	return c.Keys()[index], nil
}

// Random возвращает случайные значения из коллекции.
//
// Параметры:
//   - amount: опциональное количество случайных значений для возврата (по умолчанию 1)
//
// Возвращаемые значения:
//   - []V: срез случайных значений. Если указано N=0 или N отрицательное,
//     возвращается одно случайное значение. Если N больше размера коллекции,
//     возвращаются все элементы в случайном порядке.
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - При отсутствии параметров возвращает один случайный элемент (в срезе длины 1)
//   - Порядок значений не гарантируется — зависит от перемешивания
//   - Сложность O(n), где n - размер коллекции (из-за получения всех значений и перемешивания)
//   - Возвращает новый срез (изменение возвращенного среза не влияет на коллекцию)
//   - Использует rand.Shuffle для равномерного случайного выбора
//   - При пустой коллекции возвращает nil
//
// Примеры использования:
//
// 1. Получение одного случайного значения:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
// val := coll.Random() // например, [2]
//
// 2. Получение нескольких случайных значений:
// twoRandom := coll.Random(2) // например, [1, 3]
//
// 3. Граничные случаи:
// all := coll.Random(100)      // все значения, если коллекция меньше 100 элементов
// single := coll.Random(0)     // одно случайное значение
// empty := coll.Random(-5)     // одно случайное значение (поведение по умолчанию)
func (c *Collection[K, V]) Random(amount ...int) []V {
	c.mutex.RLock()
	defer c.mutex.RUnlock()

	values := c.Values()
	if len(values) == 0 {
		return nil
	}

	if len(amount) == 0 || amount[0] <= 0 {
		return []V{values[rand.Intn(len(values))]}
	}

	n := min(amount[0], len(values))
	rand.Shuffle(len(values), func(i, j int) { values[i], values[j] = values[j], values[i] })
	return values[:n]
}

// Find находит первое значение в коллекции, удовлетворяющее условию,
// заданному пользовательской функцией.
//
// Параметры:
//   - fn: функция-предикат, принимающая значение (V) и ключ (K),
//     возвращающая bool — true, если элемент подходит по условию
//
// Возвращаемые значения:
//   - V: найденное значение
//   - bool: true, если элемент найден; false — если ни один элемент не подошёл
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Возвращает первый найденный подходящий элемент
//   - Если ни один элемент не подходит, возвращается zero value типа V и false
//   - Для остановки перебора после первого совпадения использует break
//
// Примеры использования:
//
// 1. Поиск значения по условию:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
//	val, found := coll.Find(func(v int, k string) bool {
//	    return v > 1
//	}) // val = 2, found = true (или 3 — зависит от порядка итерации)
//
// 2. Условие не выполняется ни для одного элемента:
//
//	val, found := coll.Find(func(v int, k string) bool {
//	    return v > 10
//	}) // val = 0 (zero value), found = false
func (c *Collection[K, V]) Find(fn func(V, K) bool) (V, bool) {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	for k, v := range c.data {
		if fn(v, k) {
			return v, true
		}
	}
	var zero V
	return zero, false
}

// FindLast находит **последнее** значение в коллекции, удовлетворяющее условию,
// заданному пользовательской функцией.
//
// Параметры:
//   - fn: функция-предикат, принимающая значение (V) и ключ (K),
//     возвращающая bool — true, если элемент подходит по условию
//
// Возвращаемые значения:
//   - V: найденное значение
//   - bool: true, если элемент найден; false — если ни один элемент не подошёл
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в обратном порядке (с конца), основываясь на результате c.Keys()
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Возвращает первое подходящее значение при обходе с конца
//   - Если ни один элемент не подходит, возвращается zero value типа V и false
//   - Для остановки перебора после первого совпадения использует break
//   - Порядок итерации через c.Keys() не гарантируется (зависит от реализации map)
//
// Примеры использования:
//
// 1. Поиск последнего значения по условию:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
//	val, found := coll.FindLast(func(v int, k string) bool {
//	    return v < 3
//	}) // val = 2, found = true (или 1 — зависит от порядка итерации)
//
// 2. Условие не выполняется ни для одного элемента:
//
//	val, found := coll.FindLast(func(v int, k string) bool {
//	    return v > 10
//	}) // val = 0 (zero value), found = false
func (c *Collection[K, V]) FindLast(fn func(V, K) bool) (V, bool) {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	keys := c.Keys()
	for i := len(keys) - 1; i >= 0; i-- {
		k := keys[i]
		v := c.data[k]
		if fn(v, k) {
			return v, true
		}
	}
	var zero V
	return zero, false
}

// Sweep удаляет элементы из коллекции, удовлетворяющие условию,
// заданному пользовательской функцией.
//
// Параметры:
//   - fn: функция-предикат, принимающая значение (V) и ключ (K),
//     возвращающая true — если элемент нужно удалить
//
// Возвращаемые значения:
//   - int: количество удалённых элементов
//
// Особенности работы:
//   - Использует блокировку чтения-записи (Lock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Удаление происходит "на лету" через delete()
//   - Функция изменяет саму коллекцию (в отличие от Find или Values)
//   - Не вызывает ошибок, даже если ни один элемент не подходит под условие
//
// Примеры использования:
//
// 1. Удаление элементов по условию:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
//	count := coll.Sweep(func(v int, k string) bool {
//	    return v < 3
//	}) // может удалить "a":1 и "b":2, count = 2
//
// 2. Условие не выполняется ни для одного элемента:
//
//	count := coll.Sweep(func(v int, k string) bool {
//	    return v > 10
//	}) // count = 0, коллекция остаётся без изменений
func (c *Collection[K, V]) Sweep(fn func(V, K) bool) int {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	count := 0
	for k, v := range c.data {
		if fn(v, k) {
			delete(c.data, k)
			count++
		}
	}
	return count
}

// Filter создаёт новую коллекцию, содержащую только те элементы,
// которые удовлетворяют условию, заданному пользовательской функцией.
//
// Параметры:
//   - fn: функция-предикат, принимающая значение (V) и ключ (K),
//     возвращающая true — если элемент должен быть включён в результат
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на новую коллекцию с отфильтрованными элементами
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Создаёт новую коллекцию и копирует в неё подходящие элементы
//   - Не изменяет исходную коллекцию
//   - Работает корректно даже с пустой коллекцией (возвращает пустую)
//
// Примеры использования:
//
// 1. Фильтрация по значению:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
//	filtered := coll.Filter(func(v int, k string) bool {
//	    return v > 1
//	}) // содержит элементы с ключами "b" и "c"
//
// 2. Фильтрация по ключу:
//
//	filtered = coll.Filter(func(v int, k string) bool {
//	    return k == "a"
//	}) // содержит только элемент с ключом "a"
//
// 3. Ничего не подходит:
//
//	filtered = coll.Filter(func(v int, k string) bool {
//	    return v > 10
//	}) // возвращается пустая коллекция
func (c *Collection[K, V]) Filter(fn func(V, K) bool) *Collection[K, V] {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	result := New[K, V]()
	for k, v := range c.data {
		if fn(v, k) {
			result.Set(k, v)
		}
	}
	return result
}

// Partition разбивает коллекцию на две новые коллекции:
// одну с элементами, удовлетворяющими условию,
// другую — с теми, которые не удовлетворяют.
//
// Параметры:
//   - fn: функция-предикат, принимающая значение (V) и ключ (K),
//     возвращающая true — если элемент должен быть включён в первую коллекцию
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на коллекцию с элементами, удовлетворяющими условию
//   - *Collection[K, V]: указатель на коллекцию с элементами, не удовлетворяющими условию
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Создаёт две новые коллекции и копирует в них соответствующие элементы
//   - Не изменяет исходную коллекцию
//   - Работает корректно даже с пустой коллекцией (возвращает две пустые)
//
// Примеры использования:
//
// 1. Разделение по значению:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
//	matched, unmatched := coll.Partition(func(v int, k string) bool {
//	    return v > 1
//	})
//
// // matched содержит {"b": 2, "c": 3}
// // unmatched содержит {"a": 1}
//
// 2. Все элементы подходят:
//
//	matched, unmatched = coll.Partition(func(v int, _ string) bool {
//	    return v > 0
//	})
//
// // matched содержит все элементы
// // unmatched — пустая коллекция
//
// 3. Ни один элемент не подходит:
//
//	matched, unmatched = coll.Partition(func(v int, _ string) bool {
//	    return v > 10
//	})
//
// // matched — пустая коллекция
// // unmatched — содержит все элементы
func (c *Collection[K, V]) Partition(fn func(V, K) bool) (*Collection[K, V], *Collection[K, V]) {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	matched := New[K, V]()
	unmatched := New[K, V]()
	for k, v := range c.data {
		if fn(v, k) {
			matched.Set(k, v)
		} else {
			unmatched.Set(k, v)
		}
	}
	return matched, unmatched
}

// FlatMap применяет функцию к каждому элементу коллекции и объединяет результаты в новую коллекцию.
// Функция-обработчик должна возвращать *Collection[NewK, NewV], которая будет "развернута" в результат.
//
// Параметры:
//   - fn: функция преобразования, принимающая значение (V) и ключ (K), возвращающая коллекцию
//
// Возвращает:
//   - Новую коллекцию типа *Collection[NewK, NewV], содержащую все элементы из всех возвращенных коллекций
//
// Особенности:
//   - Поддерживает изменение типов ключей (NewK) и значений (NewV)
//   - Гарантирует потокобезопасность
//   - Сохраняет все элементы, даже если ключи дублируются (последнее значение перезаписывает предыдущее)
//
// Примеры использования:
//
// 1. Простое преобразование:
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
//
//	result := coll.FlatMap(func(v int, k string) *collection.Collection[string, string] {
//	    newColl := collection.New[string, string]()
//	    newColl.Set(k, strconv.Itoa(v))
//	    newColl.Set(k+k, "double_"+strconv.Itoa(v*2))
//	    return newColl
//	})
//
// // Результат: {"a": "1", "aa": "double_2", "b": "2", "bb": "double_4"}
//
// 2. Изменение типа ключа:
//
//	result := coll.FlatMap(func(v int, k string) *collection.Collection[int, float64] {
//	    newColl := collection.New[int, float64]()
//	    newColl.Set(len(k), float64(v)/2.0)
//	    return newColl
//	})
func (c *Collection[K, V]) FlatMap(
	fn func(V, K) *Collection[any, any],
) *Collection[any, any] {
	c.mutex.RLock()
	defer c.mutex.RUnlock()

	result := New[any, any]()

	for k, v := range c.data {
		subColl := fn(v, k)
		if subColl == nil {
			continue
		}

		subColl.mutex.RLock()
		for subK, subV := range subColl.data {
			result.Set(subK, subV)
		}
		subColl.mutex.RUnlock()
	}

	return result
}

// Map применяет функцию к каждому элементу коллекции и создаёт новую коллекцию
// с результатами применения этой функции.
//
// Параметры:
//   - fn: функция, принимающая значение (V) и ключ (K),
//     возвращающая новое значение (V) после преобразования
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на новую коллекцию с преобразованными значениями
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Создаёт новую коллекцию с теми же ключами, но обновлёнными значениями
//   - Не изменяет исходную коллекцию
//   - Работает корректно даже с пустой коллекцией (возвращает пустую)
//
// Примеры использования:
//
// 1. Преобразование значений:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
//	mapped := coll.Map(func(v int, k string) int {
//	    return v * 2
//	}) // содержит {"a": 2, "b": 4, "c": 6}
//
// 2. Изменение значений с учётом ключа:
//
//	mapped = coll.Map(func(v int, k string) int {
//	    if k == "a" {
//	        return 100
//	    }
//	    return v
//	}) // {"a": 100, "b": 2, "c": 3}
//
// 3. Работа с пустой коллекцией:
//
// empty := collection.New[string, int]()
//
//	result := empty.Map(func(v int, k string) int {
//	    return v * 10
//	}) // возвращается пустая коллекция
func (c *Collection[K, V]) Map(fn func(V, K) V) *Collection[K, V] {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	result := New[K, V]()
	for k, v := range c.data {
		result.Set(k, fn(v, k))
	}
	return result
}

// Some проверяет, удовлетворяет ли **хотя бы один** элемент коллекции
// условию, заданному пользовательской функцией.
//
// Параметры:
//   - fn: функция-предикат, принимающая значение (V) и ключ (K),
//     возвращающая true — если элемент удовлетворяет условию
//
// Возвращаемые значения:
//   - bool: true, если хотя бы один элемент удовлетворяет условию; иначе false
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Выполняет короткое вычисление — останавливается при первом совпадении
//   - Не изменяет исходную коллекцию
//   - Работает корректно даже с пустой коллекцией (возвращает false)
//
// Примеры использования:
//
// 1. Проверка наличия элемента, удовлетворяющего условию:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
//	hasEven := coll.Some(func(v int, k string) bool {
//	    return v%2 == 0
//	}) // true — так как есть значение 2
//
// 2. Условие не выполняется ни для одного элемента:
//
//	result := coll.Some(func(v int, _ string) bool {
//	    return v > 10
//	}) // false
//
// 3. Проверка на пустую коллекцию:
//
// empty := collection.New[string, int]()
//
//	result = empty.Some(func(v int, _ string) bool {
//	    return v > 0
//	}) // false — коллекция пустая
func (c *Collection[K, V]) Some(fn func(V, K) bool) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	for k, v := range c.data {
		if fn(v, k) {
			return true
		}
	}
	return false
}

// Every проверяет, удовлетворяют ли **все** элементы коллекции
// условию, заданному пользовательской функцией.
//
// Параметры:
//   - fn: функция-предикат, принимающая значение (V) и ключ (K),
//     возвращающая true — если элемент удовлетворяет условию
//
// Возвращаемые значения:
//   - bool: true, если все элементы удовлетворяют условию; иначе false
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Выполняет короткое вычисление — останавливается при первом несоответствии
//   - Не изменяет исходную коллекцию
//   - Для пустой коллекции возвращает true (согласно логике "все ноль элементов удовлетворяют условию")
//
// Примеры использования:
//
// 1. Проверка, что все элементы удовлетворяют условию:
//
// coll := collection.New[string, int]()
// coll.Set("a", 2)
// coll.Set("b", 4)
// coll.Set("c", 6)
//
//	allEven := coll.Every(func(v int, k string) bool {
//	    return v%2 == 0
//	}) // true — так как все значения чётные
//
// 2. Хотя бы один элемент не соответствует:
//
//	result := coll.Every(func(v int, _ string) bool {
//	    return v > 3
//	}) // false — так как есть значения <= 3 (например, 2)
//
// 3. Проверка на пустую коллекцию:
//
// empty := collection.New[string, int]()
//
//	result = empty.Every(func(v int, _ string) bool {
//	    return v > 0
//	}) // true — по определению: нет ни одного элемента, нарушающего условие
func (c *Collection[K, V]) Every(fn func(V, K) bool) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	for k, v := range c.data {
		if !fn(v, k) {
			return false
		}
	}
	return true
}

// Reduce применяет функцию к каждому элементу коллекции, аккумулируя результат,
// начиная с начального значения.
//
// Параметры:
//   - fn: функция, принимающая:
//   - аккумулятор (V),
//   - текущее значение (V),
//   - ключ (K)
//     возвращающая новое значение аккумулятора (V)
//   - initial: начальное значение аккумулятора
//
// Возвращаемые значения:
//   - V: конечное значение аккумулятора после обработки всех элементов
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Начальное значение используется как точка старта для аккумулятора
//   - Если коллекция пуста, возвращается initial без изменений
//   - Не изменяет исходную коллекцию
//
// Примеры использования:
//
// 1. Суммирование значений:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
//	sum := coll.Reduce(func(acc, v int, k string) int {
//	    return acc + v
//	}, 0) // 6
//
// 2. Учет ключей при вычислениях:
//
//	result := coll.Reduce(func(acc, v int, k string) int {
//	    if k == "a" {
//	        return acc + v*10
//	    }
//	    return acc + v
//	}, 0) // 1 + 2 + 3 + (если "a" = 1, то 1*10 вместо 1) → зависит от порядка итерации
//
// 3. Работа с пустой коллекцией:
//
// empty := collection.New[string, int]()
//
//	value := empty.Reduce(func(acc, v int, _ string) int {
//	    return acc * v
//	}, 5) // 5 — так как нет элементов для редукции
func (c *Collection[K, V]) Reduce(fn func(V, V, K) V, initial V) V {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	acc := initial
	for k, v := range c.data {
		acc = fn(acc, v, k)
	}
	return acc
}

// ForEach выполняет указанную функцию один раз для каждого элемента коллекции.
//
// Параметры:
//   - fn: функция, принимающая значение (V) и ключ (K)
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Не возвращает результата и не изменяет коллекцию
//   - Предназначен для побочных эффектов (например, логирование, обновление внешних данных)
//   - Работает корректно даже с пустой коллекцией (ничего не делает)
//
// Примеры использования:
//
// 1. Логирование всех элементов:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
//	coll.ForEach(func(v int, k string) {
//	    fmt.Printf("Ключ: %s, Значение: %d\n", k, v)
//	})
//
// 2. Аккумуляция во внешнюю переменную (с мьютексом при необходимости):
//
// sum := 0
// var mu sync.Mutex
//
//	coll.ForEach(func(v int, _ string) {
//	    mu.Lock()
//	    sum += v
//	    mu.Unlock()
//	})
//
// 3. Работа с пустой коллекцией:
//
// empty := collection.New[string, int]()
//
//	empty.ForEach(func(v int, k string) {
//	    // Эта функция не будет вызвана ни разу
//	})
func (c *Collection[K, V]) ForEach(fn func(V, K)) {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	for k, v := range c.data {
		fn(v, k)
	}
}

// Tap вызывает указанную функцию с самой коллекцией в качестве аргумента,
// позволяя выполнять побочные действия без изменения цепочки вызовов.
//
// Параметры:
//   - fn: функция, принимающая указатель на коллекцию (*Collection[K, V])
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на исходную коллекцию (для поддержки цепочек вызовов)
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) если внутри fn используется RLock/RLocked метод
//   - Не изменяет коллекцию напрямую (но передаёт её по ссылке — fn может изменить)
//   - Предназначен для встраивания побочных действий в цепочку вызовов
//   - Полезен для логирования, отладки, предварительной обработки и т.п.
//   - Работает корректно даже с пустой коллекцией
//
// Примеры использования:
//
// 1. Логирование состояния коллекции в середине цепочки:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1).
//
//	Set("b", 2).
//	Tap(func(c *collection.Collection[string, int]) {
//	    fmt.Printf("Текущее количество элементов: %d\n", c.Count())
//	}).
//	Set("c", 3)
//
// 2. Выполнение побочных действий с возможностью модификации коллекции:
//
//	coll.Tap(func(c *collection.Collection[string, int]) {
//	    c.Set("debug", 999)
//	})
//
// 3. Использование для тестирования промежуточного результата:
//
//	result := coll.Filter(func(v int, _ string) bool {
//	    return v > 1
//	}).Tap(func(c *collection.Collection[string, int]) {
//
//	    fmt.Println("Отфильтрованные значения:", c.Values())
//	}).Map(func(v int, k string) int {
//
//	    return v * 10
//	})
func (c *Collection[K, V]) Tap(fn func(*Collection[K, V])) *Collection[K, V] {
	fn(c)
	return c
}

// Clone создаёт полную копию коллекции, включая все её элементы.
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на новую коллекцию с теми же ключами и значениями
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Перебирает элементы в порядке итерации map, который не гарантирует стабильности
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Создаёт поверхностную копию: ключи и значения копируются по значению
//     (для указателей — копируется ссылка, а не сам объект)
//   - Не изменяет исходную коллекцию
//   - Работает корректно даже с пустой коллекцией (возвращает пустую)
//
// Примеры использования:
//
// 1. Создание независимой копии коллекции:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
//
// copyColl := coll.Clone()
//
// copyColl.Set("c", 3)
// fmt.Println(coll.Count())       // 2 — оригинальная коллекция не изменилась
// fmt.Println(copyColl.Count())   // 3 — копия модифицирована
//
// 2. Работа с пустой коллекцией:
//
// empty := collection.New[string, int]()
// clone := empty.Clone()
// fmt.Println(clone.Count())      // 0 — успешно склонирована как пустая
//
// 3. Модификация копии не влияет на оригинал:
//
// coll = collection.New[string, *User]()
// user := &User{Name: "Alice"}
// coll.Set("u1", user)
//
// copied := coll.Clone()
// copied.Get("u1").Name = "Bob"
//
// fmt.Println(coll.Get("u1").Name) // "Bob" — так как значение является указателем
func (c *Collection[K, V]) Clone() *Collection[K, V] {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	newColl := New[K, V]()
	for k, v := range c.data {
		newColl.Set(k, v)
	}
	return newColl
}

// Equals проверяет, равна ли текущая коллекция указанной по содержимому.
//
// Параметры:
//   - other: указатель на другую коллекцию того же типа (*Collection[K, V])
//
// Возвращаемые значения:
//   - bool: true — если коллекции содержат одинаковые ключи с одинаковыми значениями; иначе false
//
// Особенности работы:
//   - Использует двойную блокировку чтения (RLock) для потокобезопасного доступа к обеим коллекциям
//   - Сравнивает количество элементов, затем каждое значение по ключу
//   - Для сравнения значений используется reflect.DeepEqual
//   - Сложность O(n), где n — размер коллекции
//   - Не изменяет исходную коллекцию
//   - Работает корректно даже с пустыми коллекциями (пустая равна пустой)
//   - Учитывает типы ключей и значений, но не гарантирует порядок — так как основан на map
//
// Примеры использования:
//
// 1. Две одинаковые коллекции:
//
// coll1 := collection.New[string, int]()
// coll1.Set("a", 1).Set("b", 2)
//
// coll2 := collection.New[string, int]()
// coll2.Set("a", 1).Set("b", 2)
//
// equal := coll1.Equals(coll2) // true
//
// 2. Разное количество элементов:
//
// coll2.Set("c", 3)
// equal = coll1.Equals(coll2) // false
//
// 3. Разные значения у одного ключа:
//
// coll2.Set("a", 99)
// equal = coll1.Equals(coll2) // false
//
// 4. Сравнение с пустой коллекцией:
//
// empty1 := collection.New[string, int]()
// empty2 := collection.New[string, int]()
// equal = empty1.Equals(empty2) // true
func (c *Collection[K, V]) Equals(other *Collection[K, V]) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	other.mutex.RLock()
	defer other.mutex.RUnlock()

	if c.Size() != other.Size() {
		return false
	}
	for k, v := range c.data {
		ov, ok := other.Get(k)
		if !ok || !reflect.DeepEqual(v, ov) {
			return false
		}
	}
	return true
}

// Sort сортирует элементы коллекции в соответствии с пользовательской функцией сравнения,
// и полностью перестраивает внутреннее хранилище map на основе отсортированного порядка.
//
// Параметры:
//   - less: функция сравнения, принимающая два значения (V) и их ключи (K),
//     возвращающая true — если первый элемент должен идти перед вторым
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на текущую коллекцию (для поддержки цепочек вызовов)
//
// Особенности работы:
//   - Использует блокировку чтения-записи (Lock) для потокобезопасного доступа
//   - Преобразует map в срез пар {key, value}, сортирует его, затем пересоздаёт map
//   - Сложность O(n log n), где n — количество элементов в коллекции
//   - Изменяет исходную коллекцию (не создаёт новую)
//   - Не гарантирует стабильности сортировки при равных значениях
//   - После сортировки порядок итерации по map может отличаться от ожидаемого
//     (в Go map не сохраняет порядок, но здесь мы пересоздаём его из отсортированного среза)
//
// Примеры использования:
//
// 1. Сортировка по возрастанию значений:
//
// coll := collection.New[string, int]()
// coll.Set("a", 3)
// coll.Set("b", 1)
// coll.Set("c", 2)
//
//	coll.Sort(func(v1, v2 int, k1, k2 string) bool {
//	    return v1 < v2
//	})
//
// // внутренний map теперь содержит элементы в порядке: 1, 2, 3
//
// 2. Сортировка по убыванию значений:
//
//	coll.Sort(func(v1, v2 int, k1, k2 string) bool {
//	    return v1 > v2
//	})
//
// // внутренний map теперь содержит элементы в порядке: 3, 2, 1
//
// 3. Сортировка по ключам:
//
//	coll.Sort(func(v1, v2 int, k1, k2 string) bool {
//	    return k1 < k2
//	})
//
// // сортировка по алфавиту ключей
func (c *Collection[K, V]) Sort(less func(V, V, K, K) bool) *Collection[K, V] {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	type kv struct {
		Key   K
		Value V
	}

	items := make([]kv, 0, len(c.data))
	for k, v := range c.data {
		items = append(items, kv{k, v})
	}

	sort.Slice(items, func(i, j int) bool {
		return less(items[i].Value, items[j].Value, items[i].Key, items[j].Key)
	})

	// Create new map to preserve ordering
	newData := make(map[K]V, len(items))
	for _, item := range items {
		newData[item.Key] = item.Value
	}
	c.data = newData

	return c
}

// ToSorted создаёт новую отсортированную копию коллекции на основе
// пользовательской функции сравнения, оставляя исходную коллекцию неизменной.
//
// Параметры:
//   - less: функция сравнения, принимающая два значения (V) и их ключи (K),
//     возвращающая true — если первый элемент должен идти перед вторым
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на новую отсортированную коллекцию
//
// Особенности работы:
//   - Использует Clone() для создания копии коллекции
//   - Вызывает Sort() на копии, что гарантирует неизменность оригинала
//   - Сложность O(n log n), где n — количество элементов в коллекции
//   - Не изменяет исходную коллекцию
//   - Гарантирует потокобезопасность при работе с исходной коллекцией
//   - Полезен, когда нужно сохранить оригинальный порядок или избежать побочных эффектов
//
// Примеры использования:
//
// 1. Получение отсортированной копии по возрастанию значений:
//
// coll := collection.New[string, int]()
// coll.Set("a", 3)
// coll.Set("b", 1)
// coll.Set("c", 2)
//
//	sorted := coll.ToSorted(func(v1, v2 int, k1, k2 string) bool {
//	    return v1 < v2
//	})
//
// // coll остаётся без изменений, sorted содержит элементы в порядке возрастания
//
// 2. Сортировка по убыванию значений:
//
//	sorted = coll.ToSorted(func(v1, v2 int, k1, k2 string) bool {
//	    return v1 > v2
//	})
//
// // коллекция будет содержать значения в порядке убывания
//
// 3. Сортировка по ключам:
//
//	sorted = coll.ToSorted(func(v1, v2 int, k1, k2 string) bool {
//	    return k1 < k2
//	})
//
// // элементы будут отсортированы по алфавиту ключей
func (c *Collection[K, V]) ToSorted(less func(V, V, K, K) bool) *Collection[K, V] {
	// Create a new collection and copy data safely
	newColl := New[K, V]()

	c.mutex.RLock()
	// Create a slice of key-value pairs while holding the read lock
	type kv struct {
		Key   K
		Value V
	}
	items := make([]kv, 0, len(c.data))
	for k, v := range c.data {
		items = append(items, kv{k, v})
	}
	c.mutex.RUnlock()

	// Sort the items
	sort.Slice(items, func(i, j int) bool {
		return less(items[i].Value, items[j].Value, items[i].Key, items[j].Key)
	})

	// Populate the new collection
	newColl.mutex.Lock()
	defer newColl.mutex.Unlock()
	for _, item := range items {
		newColl.data[item.Key] = item.Value
	}

	return newColl
}

// ToReversed создаёт новую коллекцию, содержащую элементы исходной,
// но в обратном порядке.
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на новую коллекцию с элементами в обратном порядке
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) для потокобезопасного доступа
//   - Основывается на срезах ключей и значений, полученных через Keys() и Values()
//   - Сложность O(n), где n — количество элементов в коллекции
//   - Не изменяет исходную коллекцию
//   - Порядок элементов при обратной сборке зависит от порядка в срезах keys и values
//     (может отличаться от фактического порядка итерации по map)
//   - Работает корректно даже с пустой коллекцией (возвращает пустую)
//
// Примеры использования:
//
// 1. Получение обратной копии коллекции:
//
// coll := collection.New[string, int]()
// coll.Set("a", 1)
// coll.Set("b", 2)
// coll.Set("c", 3)
//
// reversed := coll.ToReversed()
//
// // reversed содержит те же элементы, но в обратном порядке (по мнению Keys()/Values())
//
// 2. Исходная коллекция остаётся неизменной:
//
// fmt.Println(coll.Values())    // [1, 2, 3]
// fmt.Println(reversed.Values()) // [3, 2, 1] (или другой порядок, если Keys() был другим)
//
// 3. Работа с пустой коллекцией:
//
// empty := collection.New[string, int]()
// result := empty.ToReversed()
// fmt.Println(result.Count())   // 0 — успешно обработана как пустая
func (c *Collection[K, V]) ToReversed() *Collection[K, V] {
	c.mutex.RLock()
	defer c.mutex.RUnlock()

	// Create a slice of key-value pairs
	type kv struct {
		key K
		val V
	}
	items := make([]kv, 0, len(c.data))
	for k, v := range c.data {
		items = append(items, kv{key: k, val: v})
	}

	// Create new collection
	reversed := New[K, V]()

	// Populate in reverse order
	for i := len(items) - 1; i >= 0; i-- {
		reversed.Set(items[i].key, items[i].val)
	}

	return reversed
}

// Intersection находит пересечение текущей коллекции с другой —
// создаёт новую коллекцию, содержащую только те элементы, ключи которых присутствуют в обеих коллекциях.
//
// Параметры:
//   - other: указатель на другую коллекцию (*Collection[K, V]) для сравнения
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на новую коллекцию, содержащую элементы-пересечения
//
// Особенности работы:
//   - Использует двойную блокировку чтения (RLock) для потокобезопасного доступа к обеим коллекциям
//   - Сравнивает **только по ключам**, значения берутся из исходной коллекции
//   - Сложность O(n), где n — количество элементов в исходной коллекции
//   - Не изменяет исходные коллекции
//   - Если пересечений нет, возвращает пустую коллекцию
//   - Работает корректно даже с пустыми коллекциями
//
// Примеры использования:
//
// 1. Нахождение общих элементов:
//
// coll1 := collection.New[string, int]()
// coll1.Set("a", 1).Set("b", 2).Set("c", 3)
//
// coll2 := collection.New[string, int]()
// coll2.Set("b", 20).Set("c", 30).Set("d", 40)
//
// intersection := coll1.Intersection(coll2)
// // intersection содержит {"b": 2, "c": 3} — ключи есть в обеих, значения из coll1
//
// 2. Нет совпадений:
//
// coll3 := collection.New[string, int]()
// coll3.Set("x", 100)
//
// intersection = coll1.Intersection(coll3)
// // intersection — пустая коллекция
//
// 3. Одна из коллекций пустая:
//
// empty := collection.New[string, int]()
// intersection = coll1.Intersection(empty)
// // intersection — пустая коллекция
func (c *Collection[K, V]) Intersection(other *Collection[K, V]) *Collection[K, V] {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	other.mutex.RLock()
	defer other.mutex.RUnlock()
	result := New[K, V]()
	for k, v := range c.data {
		if other.Has(k) {
			result.Set(k, v)
		}
	}
	return result
}

// Union создаёт новую коллекцию, содержащую все уникальные элементы из двух коллекций.
//
// При совпадении ключей значения берутся из второй коллекции (other).
//
// Параметры:
//   - other: указатель на другую коллекцию (*Collection[K, V]) для объединения
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на новую коллекцию с объединёнными элементами
//
// Особенности работы:
//   - Использует Clone() для копирования исходной коллекции
//   - Добавляет элементы из other через ForEach(), перезаписывая существующие ключи
//   - Сложность O(n), где n — общее количество элементов в обеих коллекциях
//   - Не изменяет исходные коллекции
//   - Результат содержит все ключи из обеих коллекций, с приоритетом значений из other
//   - Работает корректно даже с пустыми коллекциями
//
// Примеры использования:
//
// 1. Объединение двух коллекций:
//
// coll1 := collection.New[string, int]()
// coll1.Set("a", 1).Set("b", 2)
//
// coll2 := collection.New[string, int]()
// coll2.Set("b", 20).Set("c", 3)
//
// union := coll1.Union(coll2)
// // union содержит {"a": 1, "b": 20, "c": 3}
//
// 2. Одна из коллекций пустая:
//
// empty := collection.New[string, int]()
// union = coll1.Union(empty)
// // union == coll1
//
// 3. Обе коллекции имеют пересекающиеся ключи:
//
// collA := collection.New[string, string]()
// collA.Set("x", "old")
//
// collB := collection.New[string, string]()
// collB.Set("x", "new")
//
// result := collA.Union(collB)
// // result.Get("x") == "new" — значение из collB перезаписало исходное
func (c *Collection[K, V]) Union(other *Collection[K, V]) *Collection[K, V] {
	result := c.Clone()
	other.ForEach(func(v V, k K) { result.Set(k, v) })
	return result
}

// Difference создаёт новую коллекцию, содержащую элементы исходной коллекции,
// ключи которых **отсутствуют** во второй коллекции.
//
// Параметры:
//   - other: указатель на другую коллекцию (*Collection[K, V]) для сравнения
//
// Возвращаемые значения:
//   - *Collection[K, V]: указатель на новую коллекцию с элементами-разностями
//
// Особенности работы:
//   - Использует блокировку чтения (RLock) при переборе исходной коллекции
//   - Проверяет наличие ключей в другой коллекции через Has()
//   - Сложность O(n), где n — количество элементов в исходной коллекции
//   - Не изменяет исходные коллекции
//   - Результат содержит только те элементы, ключи которых **не найдены** в other
//   - Если все ключи совпадают или other пустая, возвращает копию исходной коллекции
//
// Примеры использования:
//
// 1. Нахождение уникальных элементов:
//
// coll1 := collection.New[string, int]()
// coll1.Set("a", 1).Set("b", 2).Set("c", 3)
//
// coll2 := collection.New[string, int]()
// coll2.Set("b", 20).Set("d", 40)
//
// diff := coll1.Difference(coll2)
// // diff содержит {"a": 1, "c": 3} — ключи, отсутствующие в coll2
//
// 2. Все ключи совпадают:
//
// coll3 := collection.New[string, int]()
// coll3.Set("a", 100).Set("b", 200).Set("c", 300)
//
// diff = coll1.Difference(coll3)
// // diff — пустая коллекция, так как все ключи из coll1 есть в coll3
//
// 3. Вторая коллекция пустая:
//
// empty := collection.New[string, int]()
// diff = coll1.Difference(empty)
// // diff == coll1 — так как ни один ключ не найден в пустой коллекции
func (c *Collection[K, V]) Difference(other *Collection[K, V]) *Collection[K, V] {
	result := New[K, V]()
	c.ForEach(func(v V, k K) {
		if !other.Has(k) {
			result.Set(k, v)
		}
	})
	return result
}

// SymmetricDifference возвращает элементы, которые есть только в одной из коллекций.
//
// Пример:
// symmetric := coll.SymmetricDifference(otherColl)
func (c *Collection[K, V]) SymmetricDifference(other *Collection[K, V]) *Collection[K, V] {
	return c.Union(other).Difference(c.Intersection(other))
}

// Merge объединяет текущую коллекцию (K, V) с другой коллекцией (K, U), применяя стратегии для:
// - Элементов, которые есть только в текущей коллекции (whenInSelf)
// - Элементов, которые есть только в другой коллекции (whenInOther)
// - Элементов, которые есть в обеих коллекциях (whenInBoth)
//
// Параметры:
//   - other: другая коллекция (может иметь другой тип значений U)
//   - whenInSelf: вызывается для элементов, уникальных для текущей коллекции
//   - whenInOther: вызывается для элементов, уникальных для другой коллекции
//   - whenInBoth: вызывается для элементов, присутствующих в обеих коллекциях
//
// Возвращает новую коллекцию (K, R), где R — тип результата.
//
// Пример использования:
//
//	coll1 := collection.New[string, int]()
//	coll2 := collection.New[string, string]()
//	coll1.Set("a", 42)
//	coll2.Set("a", "foo")
//	coll2.Set("b", "bar")
//
//	result := coll1.Merge(
//	    coll2,
//	    func(v int, k string) collection.Keep[string] { // whenInSelf
//	        return collection.KeepYes(fmt.Sprintf("%d", v))
//	    },
//	    func(u string, k string) collection.Keep[string] { // whenInOther
//	        return collection.KeepYes(strings.ToUpper(u))
//	    },
//	    func(v int, u string, k string) collection.Keep[string] { // whenInBoth
//	        return collection.KeepYes(fmt.Sprintf("%d-%s", v, u))
//	    },
//	)
//
//	// Результат:
//	// - "a" → "42-foo" (объединение)
//	// - "b" → "BAR" (только в coll2)
func (c *Collection[K, V]) Merge(
	other *Collection[K, any],
	whenInSelf func(V, K) Keep[any],
	whenInOther func(any, K) Keep[any],
	whenInBoth func(V, any, K) Keep[any],
) *Collection[K, any] {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	other.mutex.RLock()
	defer other.mutex.RUnlock()

	result := New[K, any]()
	processedKeys := make(map[K]bool)

	// Обрабатываем ключи из текущей коллекции (K, V)
	for k, v := range c.data {
		if otherVal, existsInOther := other.data[k]; existsInOther {
			// Ключ есть в обеих коллекциях → whenInBoth
			res := whenInBoth(v, otherVal, k)
			if res.keep {
				result.Set(k, res.value)
			}
		} else {
			// Ключ только в текущей → whenInSelf
			res := whenInSelf(v, k)
			if res.keep {
				result.Set(k, res.value)
			}
		}
		processedKeys[k] = true
	}

	// Обрабатываем ключи из другой коллекции (K, U), которые ещё не были обработаны
	for k, u := range other.data {
		if !processedKeys[k] {
			// Ключ только в другой → whenInOther
			res := whenInOther(u, k)
			if res.keep {
				result.Set(k, res.value)
			}
		}
	}

	return result
}

// CombineEntries создает новую коллекцию, объединяя текущие элементы с переданными записями
// с помощью функции combine. Если ключ уже существует, применяется функция объединения.
//
// Параметры:
//   - entries: срез структур {Key, Value} для объединения
//   - combine: функция объединения значений (currentValue, newValue, key) -> mergedValue
//
// Возвращаемые значения:
//   - *Collection[K, V]: новая коллекция с объединенными значениями
//
// Особенности работы:
//   - Создает и возвращает совершенно новую коллекцию
//   - Для существующих ключей вызывает функцию combine
//   - Для новых ключей просто добавляет значение
//   - Гарантирует потокобезопасность (не требует блокировки, так как работает с новой коллекцией)
//   - Сложность O(n) где n - количество переданных записей
//
// Примеры использования:
//
// 1. Объединение числовых значений (суммирование):
//
// coll := collection.New[string, int]()
// coll.Set("a", 10)
// entries := []struct{Key string; Value int}{{"a", 5}, {"b", 3}}
//
//	newColl := coll.CombineEntries(entries, func(curr, newV int, _ string) int {
//	    return curr + newV
//	})
//
// newColl.Get("a") // 15
// newColl.Get("b") // 3
//
// 2. Объединение строк (конкатенация):
// strColl := collection.New[int, string]()
// strEntries := []struct{Key int; Value string}{{1, "hello"}, {1, " world"}}
//
//	combined := strColl.CombineEntries(strEntries, func(curr, newV string, _ int) string {
//	    return curr + newV
//	})
//
// combined.Get(1) // "hello world"
func (c *Collection[K, V]) CombineEntries(entries []struct {
	Key   K
	Value V
}, combine func(V, V, K) V) *Collection[K, V] {
	// Создаем новую коллекцию и копируем текущие значения
	newColl := New[K, V]()
	c.mutex.RLock()
	for k, v := range c.data {
		newColl.Set(k, v)
	}
	c.mutex.RUnlock()

	// Объединяем с переданными записями
	for _, entry := range entries {
		if val, ok := newColl.Get(entry.Key); ok {
			newColl.Set(entry.Key, combine(val, entry.Value, entry.Key))
		} else {
			newColl.Set(entry.Key, entry.Value)
		}
	}

	return newColl
}

// GroupBy группирует элементы коллекции по заданному ключу.
//
// Параметры:
//   - items: срез элементов для группировки
//   - keySelector: функция, извлекающая ключ группировки из элемента
//
// Возвращаемые значения:
//   - *Collection[K, []T]: новая коллекция, где ключи - это значения,
//     возвращенные keySelector, а значения - срезы соответствующих элементов
//
// Особенности работы:
//   - Создает и возвращает новую коллекцию (не изменяет текущую)
//   - Гарантирует потокобезопасность (не требует блокировки текущей коллекции)
//   - Сохраняет порядок элементов в группах в соответствии с исходным срезом
//   - Сложность O(n) где n - количество элементов
//   - Не поддерживает nil элементы (может вызвать панику)
//
// Примеры использования:
//
// 1. Группировка пользователей по возрасту:
//
// type Person struct { Name string; Age int }
//
//	people := []Person{
//	    {"Alice", 25},
//	    {"Bob", 25},
//	    {"Charlie", 30},
//	}
//
//	groups := collection.GroupBy(people, func(p Person) int {
//	    return p.Age
//	})
//
// groups.Get(25) // [{Alice 25}, {Bob 25}]
//
// 2. Группировка строк по длине:
// words := []string{"apple", "banana", "cherry", "date"}
//
//	lengthGroups := collection.GroupBy(words, func(s string) int {
//	    return len(s)
//	})
//
// lengthGroups.Get(5) // ["apple", "date"]
func GroupBy[T any, K comparable](items []T, keySelector func(T) K) *Collection[K, []T] {
	groups := New[K, []T]()
	for _, item := range items {
		key := keySelector(item)
		existing, _ := groups.Get(key)
		groups.Set(key, append(existing, item))
	}
	return groups
}

// Keep используется в Merge для управления поведением.
type Keep[V any] struct {
	keep  bool
	value V
}

func KeepYes[V any](value V) Keep[V] {
	return Keep[V]{keep: true, value: value}
}

func KeepNo[V any]() Keep[V] {
	return Keep[V]{keep: false}
}

// normalizeIndex нормализует отрицательные индексы
func normalizeIndex(length, index int) int {
	if index < 0 {
		index += length
	}
	return index
}
